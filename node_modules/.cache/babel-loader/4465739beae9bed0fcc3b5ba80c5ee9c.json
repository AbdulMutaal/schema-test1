{"ast":null,"code":"/* eslint lines-around-comment: [2, {beforeBlockComment: false}] */\n\"use strict\";\n\nconst jsonParser = require(\"./parsers/json\");\n\nconst yamlParser = require(\"./parsers/yaml\");\n\nconst textParser = require(\"./parsers/text\");\n\nconst binaryParser = require(\"./parsers/binary\");\n\nconst fileResolver = require(\"./resolvers/file\");\n\nconst httpResolver = require(\"./resolvers/http\");\n\nmodule.exports = $RefParserOptions;\n/**\n * Options that determine how JSON schemas are parsed, resolved, and dereferenced.\n *\n * @param {object|$RefParserOptions} [options] - Overridden options\n * @constructor\n */\n\nfunction $RefParserOptions(options) {\n  merge(this, $RefParserOptions.defaults);\n  merge(this, options);\n}\n\n$RefParserOptions.defaults = {\n  /**\n   * Determines how different types of files will be parsed.\n   *\n   * You can add additional parsers of your own, replace an existing one with\n   * your own implementation, or disable any parser by setting it to false.\n   */\n  parse: {\n    json: jsonParser,\n    yaml: yamlParser,\n    text: textParser,\n    binary: binaryParser\n  },\n\n  /**\n   * Determines how JSON References will be resolved.\n   *\n   * You can add additional resolvers of your own, replace an existing one with\n   * your own implementation, or disable any resolver by setting it to false.\n   */\n  resolve: {\n    file: fileResolver,\n    http: httpResolver,\n\n    /**\n     * Determines whether external $ref pointers will be resolved.\n     * If this option is disabled, then none of above resolvers will be called.\n     * Instead, external $ref pointers will simply be ignored.\n     *\n     * @type {boolean}\n     */\n    external: true\n  },\n\n  /**\n   * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`\n   * causes it to keep processing as much as possible and then throw a single error that contains all errors\n   * that were encountered.\n  */\n  continueOnError: false,\n\n  /**\n   * Determines the types of JSON references that are allowed.\n   */\n  dereference: {\n    /**\n     * Dereference circular (recursive) JSON references?\n     * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.\n     * If \"ignore\", then circular references will not be dereferenced.\n     *\n     * @type {boolean|string}\n     */\n    circular: true\n  }\n};\n/**\n * Merges the properties of the source object into the target object.\n *\n * @param {object} target - The object that we're populating\n * @param {?object} source - The options that are being merged\n * @returns {object}\n */\n\nfunction merge(target, source) {\n  if (isMergeable(source)) {\n    let keys = Object.keys(source);\n\n    for (let i = 0; i < keys.length; i++) {\n      let key = keys[i];\n      let sourceSetting = source[key];\n      let targetSetting = target[key];\n\n      if (isMergeable(sourceSetting)) {\n        // It's a nested object, so merge it recursively\n        target[key] = merge(targetSetting || {}, sourceSetting);\n      } else if (sourceSetting !== undefined) {\n        // It's a scalar value, function, or array. No merging necessary. Just overwrite the target value.\n        target[key] = sourceSetting;\n      }\n    }\n  }\n\n  return target;\n}\n/**\n * Determines whether the given value can be merged,\n * or if it is a scalar value that should just override the target value.\n *\n * @param   {*}  val\n * @returns {Boolean}\n */\n\n\nfunction isMergeable(val) {\n  return val && typeof val === \"object\" && !Array.isArray(val) && !(val instanceof RegExp) && !(val instanceof Date);\n}","map":{"version":3,"names":["jsonParser","require","yamlParser","textParser","binaryParser","fileResolver","httpResolver","module","exports","$RefParserOptions","options","merge","defaults","parse","json","yaml","text","binary","resolve","file","http","external","continueOnError","dereference","circular","target","source","isMergeable","keys","Object","i","length","key","sourceSetting","targetSetting","undefined","val","Array","isArray","RegExp","Date"],"sources":["/Users/abdulmutaalazhar/Desktop/Folders/ensembleUi/schema-test1/node_modules/@apidevtools/json-schema-ref-parser/lib/options.js"],"sourcesContent":["/* eslint lines-around-comment: [2, {beforeBlockComment: false}] */\n\"use strict\";\n\nconst jsonParser = require(\"./parsers/json\");\nconst yamlParser = require(\"./parsers/yaml\");\nconst textParser = require(\"./parsers/text\");\nconst binaryParser = require(\"./parsers/binary\");\nconst fileResolver = require(\"./resolvers/file\");\nconst httpResolver = require(\"./resolvers/http\");\n\nmodule.exports = $RefParserOptions;\n\n/**\n * Options that determine how JSON schemas are parsed, resolved, and dereferenced.\n *\n * @param {object|$RefParserOptions} [options] - Overridden options\n * @constructor\n */\nfunction $RefParserOptions (options) {\n  merge(this, $RefParserOptions.defaults);\n  merge(this, options);\n}\n\n$RefParserOptions.defaults = {\n  /**\n   * Determines how different types of files will be parsed.\n   *\n   * You can add additional parsers of your own, replace an existing one with\n   * your own implementation, or disable any parser by setting it to false.\n   */\n  parse: {\n    json: jsonParser,\n    yaml: yamlParser,\n    text: textParser,\n    binary: binaryParser,\n  },\n\n  /**\n   * Determines how JSON References will be resolved.\n   *\n   * You can add additional resolvers of your own, replace an existing one with\n   * your own implementation, or disable any resolver by setting it to false.\n   */\n  resolve: {\n    file: fileResolver,\n    http: httpResolver,\n\n    /**\n     * Determines whether external $ref pointers will be resolved.\n     * If this option is disabled, then none of above resolvers will be called.\n     * Instead, external $ref pointers will simply be ignored.\n     *\n     * @type {boolean}\n     */\n    external: true,\n  },\n\n  /**\n   * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`\n   * causes it to keep processing as much as possible and then throw a single error that contains all errors\n   * that were encountered.\n  */\n  continueOnError: false,\n\n  /**\n   * Determines the types of JSON references that are allowed.\n   */\n  dereference: {\n    /**\n     * Dereference circular (recursive) JSON references?\n     * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.\n     * If \"ignore\", then circular references will not be dereferenced.\n     *\n     * @type {boolean|string}\n     */\n    circular: true\n  },\n};\n\n/**\n * Merges the properties of the source object into the target object.\n *\n * @param {object} target - The object that we're populating\n * @param {?object} source - The options that are being merged\n * @returns {object}\n */\nfunction merge (target, source) {\n  if (isMergeable(source)) {\n    let keys = Object.keys(source);\n    for (let i = 0; i < keys.length; i++) {\n      let key = keys[i];\n      let sourceSetting = source[key];\n      let targetSetting = target[key];\n\n      if (isMergeable(sourceSetting)) {\n        // It's a nested object, so merge it recursively\n        target[key] = merge(targetSetting || {}, sourceSetting);\n      }\n      else if (sourceSetting !== undefined) {\n        // It's a scalar value, function, or array. No merging necessary. Just overwrite the target value.\n        target[key] = sourceSetting;\n      }\n    }\n  }\n  return target;\n}\n\n/**\n * Determines whether the given value can be merged,\n * or if it is a scalar value that should just override the target value.\n *\n * @param   {*}  val\n * @returns {Boolean}\n */\nfunction isMergeable (val) {\n  return val &&\n    (typeof val === \"object\") &&\n    !Array.isArray(val) &&\n    !(val instanceof RegExp) &&\n    !(val instanceof Date);\n}\n"],"mappings":"AAAA;AACA;;AAEA,MAAMA,UAAU,GAAGC,OAAO,CAAC,gBAAD,CAA1B;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,gBAAD,CAA1B;;AACA,MAAME,UAAU,GAAGF,OAAO,CAAC,gBAAD,CAA1B;;AACA,MAAMG,YAAY,GAAGH,OAAO,CAAC,kBAAD,CAA5B;;AACA,MAAMI,YAAY,GAAGJ,OAAO,CAAC,kBAAD,CAA5B;;AACA,MAAMK,YAAY,GAAGL,OAAO,CAAC,kBAAD,CAA5B;;AAEAM,MAAM,CAACC,OAAP,GAAiBC,iBAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,iBAAT,CAA4BC,OAA5B,EAAqC;EACnCC,KAAK,CAAC,IAAD,EAAOF,iBAAiB,CAACG,QAAzB,CAAL;EACAD,KAAK,CAAC,IAAD,EAAOD,OAAP,CAAL;AACD;;AAEDD,iBAAiB,CAACG,QAAlB,GAA6B;EAC3B;AACF;AACA;AACA;AACA;AACA;EACEC,KAAK,EAAE;IACLC,IAAI,EAAEd,UADD;IAELe,IAAI,EAAEb,UAFD;IAGLc,IAAI,EAAEb,UAHD;IAILc,MAAM,EAAEb;EAJH,CAPoB;;EAc3B;AACF;AACA;AACA;AACA;AACA;EACEc,OAAO,EAAE;IACPC,IAAI,EAAEd,YADC;IAEPe,IAAI,EAAEd,YAFC;;IAIP;AACJ;AACA;AACA;AACA;AACA;AACA;IACIe,QAAQ,EAAE;EAXH,CApBkB;;EAkC3B;AACF;AACA;AACA;AACA;EACEC,eAAe,EAAE,KAvCU;;EAyC3B;AACF;AACA;EACEC,WAAW,EAAE;IACX;AACJ;AACA;AACA;AACA;AACA;AACA;IACIC,QAAQ,EAAE;EARC;AA5Cc,CAA7B;AAwDA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASb,KAAT,CAAgBc,MAAhB,EAAwBC,MAAxB,EAAgC;EAC9B,IAAIC,WAAW,CAACD,MAAD,CAAf,EAAyB;IACvB,IAAIE,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYF,MAAZ,CAAX;;IACA,KAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,IAAI,CAACG,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;MACpC,IAAIE,GAAG,GAAGJ,IAAI,CAACE,CAAD,CAAd;MACA,IAAIG,aAAa,GAAGP,MAAM,CAACM,GAAD,CAA1B;MACA,IAAIE,aAAa,GAAGT,MAAM,CAACO,GAAD,CAA1B;;MAEA,IAAIL,WAAW,CAACM,aAAD,CAAf,EAAgC;QAC9B;QACAR,MAAM,CAACO,GAAD,CAAN,GAAcrB,KAAK,CAACuB,aAAa,IAAI,EAAlB,EAAsBD,aAAtB,CAAnB;MACD,CAHD,MAIK,IAAIA,aAAa,KAAKE,SAAtB,EAAiC;QACpC;QACAV,MAAM,CAACO,GAAD,CAAN,GAAcC,aAAd;MACD;IACF;EACF;;EACD,OAAOR,MAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,WAAT,CAAsBS,GAAtB,EAA2B;EACzB,OAAOA,GAAG,IACP,OAAOA,GAAP,KAAe,QADX,IAEL,CAACC,KAAK,CAACC,OAAN,CAAcF,GAAd,CAFI,IAGL,EAAEA,GAAG,YAAYG,MAAjB,CAHK,IAIL,EAAEH,GAAG,YAAYI,IAAjB,CAJF;AAKD"},"metadata":{},"sourceType":"script"}