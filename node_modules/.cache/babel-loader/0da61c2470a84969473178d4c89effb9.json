{"ast":null,"code":"\"use strict\";\n/**\n * Returns the given plugins as an array, rather than an object map.\n * All other methods in this module expect an array of plugins rather than an object map.\n *\n * @param  {object} plugins - A map of plugin objects\n * @return {object[]}\n */\n\nexports.all = function (plugins) {\n  return Object.keys(plugins).filter(key => {\n    return typeof plugins[key] === \"object\";\n  }).map(key => {\n    plugins[key].name = key;\n    return plugins[key];\n  });\n};\n/**\n * Filters the given plugins, returning only the ones return `true` for the given method.\n *\n * @param  {object[]} plugins - An array of plugin objects\n * @param  {string}   method  - The name of the filter method to invoke for each plugin\n * @param  {object}   file    - A file info object, which will be passed to each method\n * @return {object[]}\n */\n\n\nexports.filter = function (plugins, method, file) {\n  return plugins.filter(plugin => {\n    return !!getResult(plugin, method, file);\n  });\n};\n/**\n * Sorts the given plugins, in place, by their `order` property.\n *\n * @param {object[]} plugins - An array of plugin objects\n * @returns {object[]}\n */\n\n\nexports.sort = function (plugins) {\n  for (let plugin of plugins) {\n    plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;\n  }\n\n  return plugins.sort((a, b) => {\n    return a.order - b.order;\n  });\n};\n/**\n * Runs the specified method of the given plugins, in order, until one of them returns a successful result.\n * Each method can return a synchronous value, a Promise, or call an error-first callback.\n * If the promise resolves successfully, or the callback is called without an error, then the result\n * is immediately returned and no further plugins are called.\n * If the promise rejects, or the callback is called with an error, then the next plugin is called.\n * If ALL plugins fail, then the last error is thrown.\n *\n * @param {object[]}  plugins - An array of plugin objects\n * @param {string}    method  - The name of the method to invoke for each plugin\n * @param {object}    file    - A file info object, which will be passed to each method\n * @returns {Promise}\n */\n\n\nexports.run = function (plugins, method, file, $refs) {\n  let plugin,\n      lastError,\n      index = 0;\n  return new Promise((resolve, reject) => {\n    runNextPlugin();\n\n    function runNextPlugin() {\n      plugin = plugins[index++];\n\n      if (!plugin) {\n        // There are no more functions, so re-throw the last error\n        return reject(lastError);\n      }\n\n      try {\n        // console.log('  %s', plugin.name);\n        let result = getResult(plugin, method, file, callback, $refs);\n\n        if (result && typeof result.then === \"function\") {\n          // A promise was returned\n          result.then(onSuccess, onError);\n        } else if (result !== undefined) {\n          // A synchronous result was returned\n          onSuccess(result);\n        } else if (index === plugins.length) {\n          throw new Error(\"No promise has been returned or callback has been called.\");\n        }\n      } catch (e) {\n        onError(e);\n      }\n    }\n\n    function callback(err, result) {\n      if (err) {\n        onError(err);\n      } else {\n        onSuccess(result);\n      }\n    }\n\n    function onSuccess(result) {\n      // console.log('    success');\n      resolve({\n        plugin,\n        result\n      });\n    }\n\n    function onError(error) {\n      // console.log('    %s', err.message || err);\n      lastError = {\n        plugin,\n        error\n      };\n      runNextPlugin();\n    }\n  });\n};\n/**\n * Returns the value of the given property.\n * If the property is a function, then the result of the function is returned.\n * If the value is a RegExp, then it will be tested against the file URL.\n * If the value is an aray, then it will be compared against the file extension.\n *\n * @param   {object}   obj        - The object whose property/method is called\n * @param   {string}   prop       - The name of the property/method to invoke\n * @param   {object}   file       - A file info object, which will be passed to the method\n * @param   {function} [callback] - A callback function, which will be passed to the method\n * @returns {*}\n */\n\n\nfunction getResult(obj, prop, file, callback, $refs) {\n  let value = obj[prop];\n\n  if (typeof value === \"function\") {\n    return value.apply(obj, [file, callback, $refs]);\n  }\n\n  if (!callback) {\n    // The synchronous plugin functions (canParse and canRead)\n    // allow a \"shorthand\" syntax, where the user can match\n    // files by RegExp or by file extension.\n    if (value instanceof RegExp) {\n      return value.test(file.url);\n    } else if (typeof value === \"string\") {\n      return value === file.extension;\n    } else if (Array.isArray(value)) {\n      return value.indexOf(file.extension) !== -1;\n    }\n  }\n\n  return value;\n}","map":{"version":3,"names":["exports","all","plugins","Object","keys","filter","key","map","name","method","file","plugin","getResult","sort","order","Number","MAX_SAFE_INTEGER","a","b","run","$refs","lastError","index","Promise","resolve","reject","runNextPlugin","result","callback","then","onSuccess","onError","undefined","length","Error","e","err","error","obj","prop","value","apply","RegExp","test","url","extension","Array","isArray","indexOf"],"sources":["/Users/abdulmutaalazhar/Desktop/Folders/ensembleUi/schema-test1/node_modules/@apidevtools/json-schema-ref-parser/lib/util/plugins.js"],"sourcesContent":["\"use strict\";\n\n/**\n * Returns the given plugins as an array, rather than an object map.\n * All other methods in this module expect an array of plugins rather than an object map.\n *\n * @param  {object} plugins - A map of plugin objects\n * @return {object[]}\n */\nexports.all = function (plugins) {\n  return Object.keys(plugins)\n    .filter((key) => {\n      return typeof plugins[key] === \"object\";\n    })\n    .map((key) => {\n      plugins[key].name = key;\n      return plugins[key];\n    });\n};\n\n/**\n * Filters the given plugins, returning only the ones return `true` for the given method.\n *\n * @param  {object[]} plugins - An array of plugin objects\n * @param  {string}   method  - The name of the filter method to invoke for each plugin\n * @param  {object}   file    - A file info object, which will be passed to each method\n * @return {object[]}\n */\nexports.filter = function (plugins, method, file) {\n  return plugins\n    .filter((plugin) => {\n      return !!getResult(plugin, method, file);\n    });\n};\n\n/**\n * Sorts the given plugins, in place, by their `order` property.\n *\n * @param {object[]} plugins - An array of plugin objects\n * @returns {object[]}\n */\nexports.sort = function (plugins) {\n  for (let plugin of plugins) {\n    plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;\n  }\n\n  return plugins.sort((a, b) => { return a.order - b.order; });\n};\n\n/**\n * Runs the specified method of the given plugins, in order, until one of them returns a successful result.\n * Each method can return a synchronous value, a Promise, or call an error-first callback.\n * If the promise resolves successfully, or the callback is called without an error, then the result\n * is immediately returned and no further plugins are called.\n * If the promise rejects, or the callback is called with an error, then the next plugin is called.\n * If ALL plugins fail, then the last error is thrown.\n *\n * @param {object[]}  plugins - An array of plugin objects\n * @param {string}    method  - The name of the method to invoke for each plugin\n * @param {object}    file    - A file info object, which will be passed to each method\n * @returns {Promise}\n */\nexports.run = function (plugins, method, file, $refs) {\n  let plugin, lastError, index = 0;\n\n  return new Promise(((resolve, reject) => {\n    runNextPlugin();\n\n    function runNextPlugin () {\n      plugin = plugins[index++];\n      if (!plugin) {\n        // There are no more functions, so re-throw the last error\n        return reject(lastError);\n      }\n\n      try {\n        // console.log('  %s', plugin.name);\n        let result = getResult(plugin, method, file, callback, $refs);\n        if (result && typeof result.then === \"function\") {\n          // A promise was returned\n          result.then(onSuccess, onError);\n        }\n        else if (result !== undefined) {\n          // A synchronous result was returned\n          onSuccess(result);\n        }\n        else if (index === plugins.length) {\n          throw new Error(\"No promise has been returned or callback has been called.\");\n        }\n      }\n      catch (e) {\n        onError(e);\n      }\n    }\n\n    function callback (err, result) {\n      if (err) {\n        onError(err);\n      }\n      else {\n        onSuccess(result);\n      }\n    }\n\n    function onSuccess (result) {\n      // console.log('    success');\n      resolve({\n        plugin,\n        result\n      });\n    }\n\n    function onError (error) {\n      // console.log('    %s', err.message || err);\n      lastError = {\n        plugin,\n        error,\n      };\n      runNextPlugin();\n    }\n  }));\n};\n\n/**\n * Returns the value of the given property.\n * If the property is a function, then the result of the function is returned.\n * If the value is a RegExp, then it will be tested against the file URL.\n * If the value is an aray, then it will be compared against the file extension.\n *\n * @param   {object}   obj        - The object whose property/method is called\n * @param   {string}   prop       - The name of the property/method to invoke\n * @param   {object}   file       - A file info object, which will be passed to the method\n * @param   {function} [callback] - A callback function, which will be passed to the method\n * @returns {*}\n */\nfunction getResult (obj, prop, file, callback, $refs) {\n  let value = obj[prop];\n\n  if (typeof value === \"function\") {\n    return value.apply(obj, [file, callback, $refs]);\n  }\n\n  if (!callback) {\n    // The synchronous plugin functions (canParse and canRead)\n    // allow a \"shorthand\" syntax, where the user can match\n    // files by RegExp or by file extension.\n    if (value instanceof RegExp) {\n      return value.test(file.url);\n    }\n    else if (typeof value === \"string\") {\n      return value === file.extension;\n    }\n    else if (Array.isArray(value)) {\n      return value.indexOf(file.extension) !== -1;\n    }\n  }\n\n  return value;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}