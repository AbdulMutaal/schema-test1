{"ast":null,"code":"\"use strict\";\n\nconst http = require(\"http\");\n\nconst https = require(\"https\");\n\nconst {\n  ono\n} = require(\"@jsdevtools/ono\");\n\nconst url = require(\"../util/url\");\n\nconst {\n  ResolverError\n} = require(\"../util/errors\");\n\nmodule.exports = {\n  /**\n   * The order that this resolver will run, in relation to other resolvers.\n   *\n   * @type {number}\n   */\n  order: 200,\n\n  /**\n   * HTTP headers to send when downloading files.\n   *\n   * @example:\n   * {\n   *   \"User-Agent\": \"JSON Schema $Ref Parser\",\n   *   Accept: \"application/json\"\n   * }\n   *\n   * @type {object}\n   */\n  headers: null,\n\n  /**\n   * HTTP request timeout (in milliseconds).\n   *\n   * @type {number}\n   */\n  timeout: 5000,\n  // 5 seconds\n\n  /**\n   * The maximum number of HTTP redirects to follow.\n   * To disable automatic following of redirects, set this to zero.\n   *\n   * @type {number}\n   */\n  redirects: 5,\n\n  /**\n   * The `withCredentials` option of XMLHttpRequest.\n   * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication\n   *\n   * @type {boolean}\n   */\n  withCredentials: false,\n\n  /**\n   * Determines whether this resolver can read a given file reference.\n   * Resolvers that return true will be tried in order, until one successfully resolves the file.\n   * Resolvers that return false will not be given a chance to resolve the file.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {boolean}\n   */\n  canRead(file) {\n    return url.isHttp(file.url);\n  },\n\n  /**\n   * Reads the given URL and returns its raw contents as a Buffer.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {Promise<Buffer>}\n   */\n  read(file) {\n    let u = url.parse(file.url);\n\n    if (process.browser && !u.protocol) {\n      // Use the protocol of the current page\n      u.protocol = url.parse(location.href).protocol;\n    }\n\n    return download(u, this);\n  }\n\n};\n/**\n * Downloads the given file.\n *\n * @param {Url|string} u        - The url to download (can be a parsed {@link Url} object)\n * @param {object} httpOptions  - The `options.resolve.http` object\n * @param {number} [redirects]  - The redirect URLs that have already been followed\n *\n * @returns {Promise<Buffer>}\n * The promise resolves with the raw downloaded data, or rejects if there is an HTTP error.\n */\n\nfunction download(u, httpOptions, redirects) {\n  return new Promise((resolve, reject) => {\n    u = url.parse(u);\n    redirects = redirects || [];\n    redirects.push(u.href);\n    get(u, httpOptions).then(res => {\n      if (res.statusCode >= 400) {\n        throw ono({\n          status: res.statusCode\n        }, `HTTP ERROR ${res.statusCode}`);\n      } else if (res.statusCode >= 300) {\n        if (redirects.length > httpOptions.redirects) {\n          reject(new ResolverError(ono({\n            status: res.statusCode\n          }, `Error downloading ${redirects[0]}. \\nToo many redirects: \\n  ${redirects.join(\" \\n  \")}`)));\n        } else if (!res.headers.location) {\n          throw ono({\n            status: res.statusCode\n          }, `HTTP ${res.statusCode} redirect with no location header`);\n        } else {\n          // console.log('HTTP %d redirect %s -> %s', res.statusCode, u.href, res.headers.location);\n          let redirectTo = url.resolve(u, res.headers.location);\n          download(redirectTo, httpOptions, redirects).then(resolve, reject);\n        }\n      } else {\n        resolve(res.body || Buffer.alloc(0));\n      }\n    }).catch(err => {\n      reject(new ResolverError(ono(err, `Error downloading ${u.href}`), u.href));\n    });\n  });\n}\n/**\n * Sends an HTTP GET request.\n *\n * @param {Url} u - A parsed {@link Url} object\n * @param {object} httpOptions - The `options.resolve.http` object\n *\n * @returns {Promise<Response>}\n * The promise resolves with the HTTP Response object.\n */\n\n\nfunction get(u, httpOptions) {\n  return new Promise((resolve, reject) => {\n    // console.log('GET', u.href);\n    let protocol = u.protocol === \"https:\" ? https : http;\n    let req = protocol.get({\n      hostname: u.hostname,\n      port: u.port,\n      path: u.path,\n      auth: u.auth,\n      protocol: u.protocol,\n      headers: httpOptions.headers || {},\n      withCredentials: httpOptions.withCredentials\n    });\n\n    if (typeof req.setTimeout === \"function\") {\n      req.setTimeout(httpOptions.timeout);\n    }\n\n    req.on(\"timeout\", () => {\n      req.abort();\n    });\n    req.on(\"error\", reject);\n    req.once(\"response\", res => {\n      res.body = Buffer.alloc(0);\n      res.on(\"data\", data => {\n        res.body = Buffer.concat([res.body, Buffer.from(data)]);\n      });\n      res.on(\"error\", reject);\n      res.on(\"end\", () => {\n        resolve(res);\n      });\n    });\n  });\n}","map":{"version":3,"names":["http","require","https","ono","url","ResolverError","module","exports","order","headers","timeout","redirects","withCredentials","canRead","file","isHttp","read","u","parse","process","browser","protocol","location","href","download","httpOptions","Promise","resolve","reject","push","get","then","res","statusCode","status","length","join","redirectTo","body","Buffer","alloc","catch","err","req","hostname","port","path","auth","setTimeout","on","abort","once","data","concat","from"],"sources":["/Users/abdulmutaalazhar/Desktop/Folders/ensembleUi/schema-test1/node_modules/@apidevtools/json-schema-ref-parser/lib/resolvers/http.js"],"sourcesContent":["\"use strict\";\n\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst { ono } = require(\"@jsdevtools/ono\");\nconst url = require(\"../util/url\");\nconst { ResolverError } = require(\"../util/errors\");\n\nmodule.exports = {\n  /**\n   * The order that this resolver will run, in relation to other resolvers.\n   *\n   * @type {number}\n   */\n  order: 200,\n\n  /**\n   * HTTP headers to send when downloading files.\n   *\n   * @example:\n   * {\n   *   \"User-Agent\": \"JSON Schema $Ref Parser\",\n   *   Accept: \"application/json\"\n   * }\n   *\n   * @type {object}\n   */\n  headers: null,\n\n  /**\n   * HTTP request timeout (in milliseconds).\n   *\n   * @type {number}\n   */\n  timeout: 5000, // 5 seconds\n\n  /**\n   * The maximum number of HTTP redirects to follow.\n   * To disable automatic following of redirects, set this to zero.\n   *\n   * @type {number}\n   */\n  redirects: 5,\n\n  /**\n   * The `withCredentials` option of XMLHttpRequest.\n   * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication\n   *\n   * @type {boolean}\n   */\n  withCredentials: false,\n\n  /**\n   * Determines whether this resolver can read a given file reference.\n   * Resolvers that return true will be tried in order, until one successfully resolves the file.\n   * Resolvers that return false will not be given a chance to resolve the file.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {boolean}\n   */\n  canRead (file) {\n    return url.isHttp(file.url);\n  },\n\n  /**\n   * Reads the given URL and returns its raw contents as a Buffer.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {Promise<Buffer>}\n   */\n  read (file) {\n    let u = url.parse(file.url);\n\n    if (process.browser && !u.protocol) {\n      // Use the protocol of the current page\n      u.protocol = url.parse(location.href).protocol;\n    }\n\n    return download(u, this);\n  }\n};\n\n/**\n * Downloads the given file.\n *\n * @param {Url|string} u        - The url to download (can be a parsed {@link Url} object)\n * @param {object} httpOptions  - The `options.resolve.http` object\n * @param {number} [redirects]  - The redirect URLs that have already been followed\n *\n * @returns {Promise<Buffer>}\n * The promise resolves with the raw downloaded data, or rejects if there is an HTTP error.\n */\nfunction download (u, httpOptions, redirects) {\n  return new Promise(((resolve, reject) => {\n    u = url.parse(u);\n    redirects = redirects || [];\n    redirects.push(u.href);\n\n    get(u, httpOptions)\n      .then((res) => {\n        if (res.statusCode >= 400) {\n          throw ono({ status: res.statusCode }, `HTTP ERROR ${res.statusCode}`);\n        }\n        else if (res.statusCode >= 300) {\n          if (redirects.length > httpOptions.redirects) {\n            reject(new ResolverError(ono({ status: res.statusCode },\n              `Error downloading ${redirects[0]}. \\nToo many redirects: \\n  ${redirects.join(\" \\n  \")}`)));\n          }\n          else if (!res.headers.location) {\n            throw ono({ status: res.statusCode }, `HTTP ${res.statusCode} redirect with no location header`);\n          }\n          else {\n            // console.log('HTTP %d redirect %s -> %s', res.statusCode, u.href, res.headers.location);\n            let redirectTo = url.resolve(u, res.headers.location);\n            download(redirectTo, httpOptions, redirects).then(resolve, reject);\n          }\n        }\n        else {\n          resolve(res.body || Buffer.alloc(0));\n        }\n      })\n      .catch((err) => {\n        reject(new ResolverError(ono(err, `Error downloading ${u.href}`), u.href));\n      });\n  }));\n}\n\n/**\n * Sends an HTTP GET request.\n *\n * @param {Url} u - A parsed {@link Url} object\n * @param {object} httpOptions - The `options.resolve.http` object\n *\n * @returns {Promise<Response>}\n * The promise resolves with the HTTP Response object.\n */\nfunction get (u, httpOptions) {\n  return new Promise(((resolve, reject) => {\n    // console.log('GET', u.href);\n\n    let protocol = u.protocol === \"https:\" ? https : http;\n    let req = protocol.get({\n      hostname: u.hostname,\n      port: u.port,\n      path: u.path,\n      auth: u.auth,\n      protocol: u.protocol,\n      headers: httpOptions.headers || {},\n      withCredentials: httpOptions.withCredentials\n    });\n\n    if (typeof req.setTimeout === \"function\") {\n      req.setTimeout(httpOptions.timeout);\n    }\n\n    req.on(\"timeout\", () => {\n      req.abort();\n    });\n\n    req.on(\"error\", reject);\n\n    req.once(\"response\", (res) => {\n      res.body = Buffer.alloc(0);\n\n      res.on(\"data\", (data) => {\n        res.body = Buffer.concat([res.body, Buffer.from(data)]);\n      });\n\n      res.on(\"error\", reject);\n\n      res.on(\"end\", () => {\n        resolve(res);\n      });\n    });\n  }));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}